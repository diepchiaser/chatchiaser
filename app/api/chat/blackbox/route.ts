import { ChatSettings } from "@/types"

interface BlackboxMessage {
  id: string
  content: string
  role: string
}

export async function POST(request: Request) {
  const json = await request.json()
  const {
    chatSettings,
    messages,
    maxRetries = 3,
    delay = 1,
    proxy
  } = json as {
    chatSettings: ChatSettings
    messages: any[]
    maxRetries?: number
    delay?: number
    proxy?: string
  }

  const generateRandomId = (length: number = 7): string => {
    const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    return Array.from({ length }, () =>
      characters.charAt(Math.floor(Math.random() * characters.length))
    ).join("")
  }

  try {
    const chatId = generateRandomId()
    const formattedMessages: BlackboxMessage[] = messages.map(msg => ({
      id: generateRandomId(),
      content: msg.content,
      role: msg.role
    }))

    const body = {
      messages: formattedMessages,
      id: chatId,
      previewToken: null,
      userId: null,
      codeModelMode: true,
      agentMode: {},
      trendingAgentMode: {},
      isMicMode: false,
      isChromeExt: false,
      deepSearchMode: false,
      domains: null,
      githubToken: null,
      clickedAnswer2: false,
      clickedAnswer3: false,
      clickedForceWebSearch: false,
      imageGenerationMode: false,
      mobileClient: false,
      userSystemPrompt: null,
      visitFromDelta: false,
      webSearchMode: false,
      userSelectedModel: chatSettings.model,
      maxTokens: 1024,
      playgroundTemperature: chatSettings.temperature,
      webSearchModePrompt: false
    }

    const response = await fetch("https://www.blackbox.ai/api/chat", {
      headers: {
        accept: "*/*",
        "accept-language": "en-US,en;q=0.9",
        "content-type": "application/json",
        origin: "https://www.blackbox.ai",
        referer: "https://www.blackbox.ai/",
        "user-agent":
          "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
      },
      body: JSON.stringify(body),
      method: "POST",
      credentials: "omit"
    })

    if (!response.ok) {
      return new Response(JSON.stringify({ message: response.statusText }), {
        status: response.status,
        headers: { "Content-Type": "application/json" }
      })
    }

    const readableStream = new ReadableStream({
      async start(controller) {
        try {
          const reader = response.body?.getReader()
          if (!reader) {
            controller.close()
            return
          }

          while (true) {
            const { done, value } = await reader.read()
            if (done) break

            const text = new TextDecoder().decode(value)
            const lastIndex = text.lastIndexOf("$")
            let cleanedText =
              lastIndex !== -1 ? text.slice(lastIndex + 1) : text

            // Clean up response text
            cleanedText = cleanedText
              .replace(
                /Generated by BLACKBOX\.AI, try unlimited chat https:\/\/www\.blackbox\.ai/g,
                ""
              )
              .replace(
                /and for API requests replace  https:\/\/www\.blackbox\.ai with https:\/\/api\.blackbox\.ai/g,
                ""
              )
              .trim()

            if (cleanedText) {
              const jsonMatch = cleanedText.match(/\$~~~\$(.*?)\$~~~\$/)
              if (jsonMatch) {
                const searchResults = JSON.parse(jsonMatch[1])
                const answer = cleanedText.split("$~~~$").pop()?.trim() || ""

                let formattedResponse = `${answer}\n\n**Source:**`
                searchResults.forEach((result: any, index: number) => {
                  formattedResponse += `\n${index + 1}. ${result.title}: ${result.link}`
                })

                controller.enqueue(formattedResponse)
              } else {
                controller.enqueue(cleanedText)
              }
            }
          }
        } catch (error) {
          controller.error(error)
        } finally {
          controller.close()
        }
      }
    })

    return new Response(readableStream, {
      headers: {
        "Content-Type": "text/plain",
        "Transfer-Encoding": "chunked"
      }
    })
  } catch (error: any) {
    console.log("error: ", error)
    let errorMessage = error.message || "An unexpected error occurred"
    const errorCode = error.status || 500

    return new Response(JSON.stringify({ message: errorMessage }), {
      status: errorCode
    })
  }
}
